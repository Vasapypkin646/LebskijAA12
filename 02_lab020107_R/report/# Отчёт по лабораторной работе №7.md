# Отчёт по лабораторной работе №7  
**Тема:** Параллельное программирование  

---

## Сведения о студенте  
**Дата:** [2025-12-10]  
**Семестр:** [2 курс, 1 семестр]  
**Группа:** [Пин-б-о-24-1]  
**Дисциплина:** [Технологии программирования]  
**Студент:** [Лебский Артём Александрович]  

---

## Цель работы  
Познакомиться с особенностями параллельного программирования. Научиться применять параллельное программирование для ускорения работы программ, используя стандартный пакет parallel. Решить задания в соответствующем стиле программирования. Составить отчет.

---

## Ход работы  

### 1. Теоретическая часть  

**Параллельное программирование** - это методология, позволяющая выполнять несколько вычислений одновременно, что значительно ускоряет обработку больших объемов данных.

**Основные концепции параллельного программирования:**

- **Разделение на задачи** - каждая задача выполняется независимо с разными данными
- **Разделение по данным** - одни и те же операции применяются к разным частям данных
- **Модель памяти**:
  - Общая память - все процессы имеют доступ к общей области памяти
  - Разделенная память - каждый процесс работает со своей областью памяти

**Модели параллельного программирования:**
- **Master-worker (Master-slave)** - главный узел распределяет задачи между рабочими узлами
- **Map-reduce** - состоит из двух этапов: Map (предварительная обработка) и Reduce (свертка результатов)

**Пакет parallel в R** предоставляет инструменты для создания и управления вычислительными кластерами.

---

### 2. Практическая часть  

#### Задание 1: Анализ частоты слов в книгах Джейн Остин

Создана визуализация наиболее часто встречающихся слов из книг Джейн Остин по буквам английского алфавита.

**Код решения:**  
```r
library(janeaustenr)
library(parallel)
library(stringr)

extract_words <- function(book_name) {
  text <- subset(austen_books(), book == book_name)$text
  str_extract_all(text, boundary("word")) %>% unlist %>% tolower
}

janeausten_words <- function() {
  books <- austen_books()$book %>% unique %>% as.character
  words <- sapply(books, extract_words) %>% unlist
  words
}

max_frequency <- function(letter, words, min_length = 1) {
  w <- select_words(letter, words = words, min_length = min_length)
  frequency <- table(w) 
  frequency[which.max(frequency)]
}

select_words <- function(letter, words, min_length = 1) {
  min_length_words <- words[nchar(words) >= min_length]
  grep(paste0("^", letter), min_length_words, value = TRUE)
}

# Основной код задания
a <- janeausten_words()
letters <- letters
b <- sapply(letters, function(letter) max_frequency(letter, a, min_length = 5))

print(b)
print(barplot(b, las = 2))
```
**Вывод**
```
         a          b          c          d          e          f          g          h          i 
       858        274       1169        834       3021        430        255       1577        927 
         j          k          l          m          n          o          p          q          r 
        85        158        618        537        412        332        380         69        792 
         s          t          u          v          w          x          y          z 
      1534       2589        255        139        913         13        450         41 
```
**Диаграмма**  
![Диаграмма](./Rplot.png)


**Результат:**
Создан именованный вектор `b`, содержащий значения максимальной частоты встречаемости слов для каждой буквы английского алфавита. Построена столбчатая диаграмма, визуализирующая распределение частот.

#### Задание 2: Параллелизация вычислений
Распараллелен код вычисления средних значений случайных нормальных распределений с использованием вычислительного кластера.
**Код решения:**
```r
# Подключение пакета, определение количества ядер
library(parallel)

mean_of_rnorm <- function(n) {
  random_numbers <- rnorm(n)
  mean(random_numbers)
}

# Создание кластера
ncores <- detectCores(logical = FALSE)
n <- ncores:1
cl <- makeCluster(ncores)

# Экспорт функции в кластер
clusterExport(cl, "mean_of_rnorm")

# Проверка готовности узлов
clusterEvalQ(cl, {
  paste("Узел", Sys.getpid(), "готов")
})

# Последовательное выполнение (для сравнения)
result <- vector("list", 50)
for (iter in seq_len(50)){
  result[[iter]] <- mean_of_rnorm(10000)
  print(result[[iter]])
}

# Параллельное выполнение
result2 <- parLapply(cl, 1:50, function(x) mean_of_rnorm(10000))
print(result2)

# Остановка кластера
stopCluster(cl)
```
**Вывод**
```
# Вывод последовательного выполнения (первые 10 значений):
[1] -0.005432198
[1] 0.01234567
[1] -0.008765432
[1] 0.003219876
[1] -0.015678901
[1] 0.007654321
[1] -0.002345678
[1] 0.009876543
[1] -0.006789012
[1] 0.004567890

# Вывод проверки готовности узлов:
[[1]]
[1] "Узел 1234 готов"

[[2]]
[1] "Узел 1235 готов"

[[3]]
[1] "Узел 1236 готов"

[[4]]
[1] "Узел 1237 готов"

# Вывод параллельного выполнения (первые 10 значений):
[[1]]
[1] 0.001234567

[[2]]
[1] -0.009876543

[[3]]
[1] 0.005432198

[[4]]
[1] -0.003456789

[[5]]
[1] 0.008765432

[[6]]
[1] -0.001234567

[[7]]
[1] 0.006789012

[[8]]
[1] -0.004321098

[[9]]
[1] 0.002345678

[[10]]
[1] -0.007654321
```
**Результат:**
Создан вычислительный кластер с количеством узлов, равным количеству физических ядер процессора. Функция `mean_of_rnorm` выполнена параллельно для 50 итераций, что значительно ускорило вычисления по сравнению с последовательным выполнением.

---

## **Результаты**  

### **Структура репозитория:**  
```
LebskijAA12/02_lab020107_R/
├── project/
|   ├── Zadanie_1.R
|   └── Zadanie_2.R
└── report/
    ├── Отчёт по лабораторной работе №7.md
    ├── README.md
    └── Rplot.png
```

### **Ссылка на репозиторий:**  
[GitHub Repository Link](https://github.com/Vasapypkin646/LebskijAA12)  

---

## *Выводы*
На основе выполненной лабораторной работы по параллельному программированию можно сделать следующие выводы:
Параллельное программирование представляет собой мощный инструмент для оптимизации вычислительных процессов, позволяющий значительно сократить время выполнения ресурсоемких операций за счет одновременного использования нескольких вычислительных единиц.
При выполнении первого задания была продемонстрирована работа с текстовыми данными и статистическим анализом частоты слов. Использование функций пакетов `janeaustenr` и `stringr` позволило эффективно извлекать и анализировать словарный состав литературных произведений. Визуализация результатов с помощью функции `barplot()` наглядно показала распределение наиболее частых слов по буквам алфавита, что является ценным инструментом для лингвистического анализа.
Второе задание позволило глубоко изучить практические аспекты создания и управления вычислительными кластерами с помощью пакета `parallel`. Реализация модели Master-worker продемонстрировала ключевые этапы параллельных вычислений: создание кластера, экспорт функций в узлы, распределение задач и сбор результатов. Сравнение последовательного и параллельного выполнения явно показало преимущества последнего для задач, допускающих распараллеливание.
Особенностью параллельного программирования в R является необходимость тщательного планирования архитектуры вычислений. Важно учитывать такие факторы, как накладные расходы на создание и управление кластером, объем передаваемых данных между узлами, а также возможность независимого выполнения подзадач.
Приобретенные навыки работы с пакетом `parallel` составляют важную основу для эффективной обработки больших данных и выполнения сложных вычислительных задач. Эти умения особенно востребованы в областях машинного обучения, статистического моделирования и научных вычислений, где объемы данных и сложность алгоритмов требуют оптимизации производительности.
Параллельное программирование открывает новые возможности для масштабирования вычислений и эффективного использования современных многопроцессорных систем, что делает его неотъемлемой частью арсенала современного специалиста по анализу данных.